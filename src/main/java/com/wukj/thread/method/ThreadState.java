package com.wukj.thread.method;

public class ThreadState {

	/**
	 * 一、线程的状态，可以分为7种状态 1.创建[new]----------创建一个新的线程
	 * 2.就绪[runnable]-----就绪之前需要加载内存资源，包括程序计数器，Java栈，本地方法，为线程分配内存空间
	 * 3.运行[running]------当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。
	 * 4.阻塞[blocked]------当被同步代码块或者同步方法修饰，线程进入阻塞状态。
	 * 5.休眠[timewaiting]--主动休眠，休眠一段时间载进行执行。 6.等待[waiting]------主动等待，用户让线程主动等待。
	 * 7.消亡[dead]---------当由于突然中断或者子任务执行完毕，线程就会被消亡。
	 * 
	 * 
	 * 二、上下文切换
	 * 对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）
	 * 
	 * 
	 * 三、Thread中的方法
	 * Thread类实现了Runnable接口，在Thread类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。
	 * 
	 * 下面是Thread类中常用的方法：
	 * 1.start方法----：start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。
	 * 
	 * 2.run方法------：run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。
	 * 
	 * 3.sleep方法----：sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。
	 * sleep方法有两个重载版本： //参数为毫秒 sleep(long millis) //第一参数为毫秒，第二个参数为纳秒 sleep(long
	 * millis,int nanoseconds)
	 * 
	 * 4.yield方法----：调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
	 * 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。
	 * 
	 * 5.join方法-----：假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。
	 * join方法有三个重载版本： join() //参数为毫秒 join(long millis) //第一参数为毫秒，第二个参数为纳秒 join(long
	 * millis,int nanoseconds)
	 * 实际上调用join方法是调用了Object的wait方法，wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。
	 * 由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。
	 * 
	 * 6.interrupt方法-：interrupt，顾名思义，即中断的意思。单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。
	 * 运行该程序会发现，while循环会一直运行直到变量i的值超出Integer.MAX_VALUE。所以说直接调用interrupt方法不能中断正在运行中的线程。
	 * 但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行
	 * 
	 * 7.stop方法------:stop方法已经是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。
	 * 8.destroy方法---:destroy方法也是废弃的方法。基本不会被使用到。
	 * 
	 * 以下是关系到线程属性的几个方法：
	 * 1）getId：用来得到线程ID
	 * 2）getName和setName：用来得到或者设置线程名称。
	 * 3）getPriority和setPriority：用来获取和设置线程优先级。
	 * 4）setDaemon和isDaemon：用来设置线程是否成为守护线程和判断线程是否是守护线程。
	 * 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。
	 * 
	 * Thread类有一个比较常用的静态方法currentThread()用来获取当前线程。
	 * 
	 * 
	 */
	 
	 
}
